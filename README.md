# GameBirdsVsPlane
Полное развёрнутое описание игрового процесса и подкапотного исполнения 2д игры **самолётик против птичек**.
+ [Функционал](#Func);
+ [Реализация](#Realiz);


## <a name="Func"></a> Функционал:
Игра, в которой пользователь играет за самолётик, задача которого сбивать злых птичек. Присутствует беззвучный режим. Присутствует графика, анимация летящего самолётика, сломанного самолётика, стреляющего самолётика, вылетающей пули и летящих птичек, а так же меняющегося заднего фона.А так же возможность подсчёта очков

## <a name="Realiz"></a> Реализация:
+ [Реализация фона](#Back)
+ [Реализация самолётика](#Plane)
+ [Реализация выстрелов](#Shoot)
+ [Реализация птичек](#Birds)
+ [Реализация столкновения самолётика и птички](#Collision1)
+ [Реализация столкновения птички и пули](#Collision2)
+ [Реализация внутриигровой логики проигрыша](#Lose)
+ [Реализация внутриигровой логики очков](#Score)
+ [Реализация звуков](#Sound)

### <a name="Back"></a> Фон:
Для создания и иницализации фона мною был создан класс *Background.java*. Внутри класса существуют три поля: координата x, координата y и растровое изображение.Внутри класса *GameView.java* в конструкторе создаётся два обьекта класса *Background.java*, и в методе update()(который постоянно вызывается внутри метода run, пока приложение запущено),  происходит сдвиг двух обьектов на 10 пискселей влево, а затем в методе draw рисуются два фона. Сдвиг происходит за счёт того, что изначально координате x второго обьекта присваивается конечная координата оси абсцисс и когда заканчивается первый фон, сразу начинается второй.

### <a name="Plane"></a> Самолётик:
Для самолётика так же был создан отдельный класс *Flight.java*. Внутри класса реализованы следующие поля: численные переменные x,y,width,height,wingCounter = 0,ShootCounter(о нём позже), логическая переменная isGoingUp, растры flight(1-2), shoot(1-5)(о них позже), dead(позже). В методе getFlight(который возвращает Bitmap) происходит проверка: если wingCounter ноль, то тогда возвращается изображение flight1 , если нет flight2.В классе *GameView.java* в методе onTouchEvent проверяется нажатие на левую половину экрана. Если да: isGoing = true, нет: false. Далее в методе update проверяется проверяется isGoingUp и в зависимости от значения поднимается или опускается на 30 пикселей. Так же проверяется чтобы самолётик не вышел за пределы экрана.

### <a name="Shoot"></a> Выстрелы:
Для выстрелов был создан класс *Bullet.java*, поля которого: целочисленные x,y,width,height. При нажатии на правую половину экрана инкрементируется переменная toShoot и в методе getFlight поочереди(в зависимости от значения) возвращаются изображения стреляющего самолётика). Координаты выстрела напрямую зависят от координат самолётика. В методе update для каждого выстрела происходит проверка на нахождении в пределах экрана, изменение координаты пули по оси x +50 пискселей от места выстрела, координата y не меняется.А затем в методе draw() рисуются все пули.

### <a name="Birds"></a> Птички:
Для птичек был так же создан отдельный класс *Bird.java*. В методе updare() в foreach цикле задаётся местоположение птички относительно y координаты(случайным образом, но в пределах экрана).А так же случайным образом задаётся измнения птички вдоль оси x(скорость), так же с ограничением, хотя изначальная скорость 10 пикселей. Если птичка столкнулась с самолётиком или оказалось с ним на одном уровне относительно оси x игра закончилась. Птичка так же рисуется в методе draw() поочереди(от 1 до 4 изображений).

### <a name="Collision1"></a> Столкновение самолётика и птички:
Внутри классов *Bird.java* и *Flight.java* реализованы методы getCollisionShape(), которые возвращают прямоугольник относительно их размеров. А так же внутри *Flight.java* есть метод getDead(), который возвращает раст подбитого самолётика. В цикле foreach метода update() проверяется координаты птички, если они меньше нуля, или если пересеклись два прямоугольника из getCollisionShape, то в условии внутри метода draw значение переменной isPlaying становится false и игра остнавливается и возвращается начальный экран.

### <a name="Collision2"></a> Столкновение самолётика и выстрела:
Аналогично с классами *Bird.java* и *Flight.java*, в классе *Bullet.java* так же реализован метод getCollisionShape(). Внутри метода update, есть цикл foreach для пуль, внутри него есть метод, который проверяет было ли столкновение прямоугольников пули и птички. Если было то поле wasShot принимает значение true и следовательно эта птичка уже никак не влияет на результат игры(помимо счёта) и как следствие птичка исчезает за пределы экрана.

### <a name="Lose"></a> Проигрыш:
Всего существует два способа проиграть:
1.	Когда прямоугольник, в котором находится птичка, сталкивается с прямоугольником, в котором находится самолётик.
2.	Если птичка долетает до начала координат относительно оси абсцисс.

### <a name="Score"></a> Очки:
Изначально значение переменной score в классе *GameView.java* равняется нулю. В случае столкновения пули и птички значение переменной score инкрементируется. Сохрание рекорда происходит следующим образом: в методе saveHighScore проверяется условие больше ли значение score чем рекорд который есть сейчас(изначально нуль), если да, то меняем значение highscore на сount. А далее в классе *MainActivity.java* в переменную highScoreTxt с помощью SharedPrefernces передаётся значение рекорда.

### <a name="Sound"></a> Звуки:
В данной игре было реализовано звуковое сопровождение выстрелов.В конструкте класса *GameView.java* проинициализирован в зависимости от версии сборки объект класса SoundPool, в конечном итоге переменная принимает значение звука shoot.mp3, который находится в папке raw. Непосредственно само сопровождение реализуется внутри метода newBullet, а именно проверяется какой режим игры выбран(со звуком или без) ,передача информации происходит при помощи класса SharedPreferences, если выбран режим со звуком(который стоит по умолчанию), то воспроизводится аудиодорожка в момент создания пули, если режим беззвучный ничего не происходит.
